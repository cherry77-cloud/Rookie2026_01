## 一. `std::vector` 的扩容过程

当向 `std::vector` 添加元素并且当前容量不足以容纳新元素时，`std::vector` 会进行扩容。扩容过程通常包括以下步骤：
- 分配更大的内存块：通常是当前容量的两倍（具体增长因子取决于实现）。
- 移动元素到新内存：将当前所有元素移动到新分配的内存中。
- 销毁旧元素并释放旧内存：释放旧内存块。
- 插入新元素：将新元素添加到扩容后的内存中。

---

## 二. `std::vector::push_back` 和 `std::vector::emplace_back` 的区别
两者都用于在 `std::vector` 的末尾添加新元素，但它们的实现方式不同：

`push_back`
- 对给定的对象进行拷贝或移动构造。
- 需要先构造对象，再将其拷贝或移动到 `vector` 中。
- 适用于已有对象的情况。

`emplace_back`
- 直接在 `vector` 的末尾构造新元素，无需拷贝或移动操作。
- 通过传递构造参数，直接在容器内部构造对象。
- 更高效，尤其是对于复杂对象。

---

## 三. 什么时候会使用 `std::vector::reserve()`
`std::vector::reserve()` 用于预分配内存，以避免在添加新元素时频繁重新分配内存。

- 当知道将要存储大量元素时。希望避免频繁的内存重新分配和元素拷贝。
- 提高性能，减少内存分配和元素移动的开销。

---

## 四. 如果 `std::vector` 的元素是指针，需要注意什么
当 `std::vector` 存储指针时，需要注意以下问题：

- **内存管理**：需要手动释放指针指向的内存，否则会导致内存泄漏。
- **所有权和生命周期**：确保指针指向的对象在 `vector` 使用期间有效。明确谁拥有对象的所有权。
- **异常安全**：在构造和填充 `vector` 时，确保异常发生时不会泄漏内存。
- **智能指针**：推荐使用 `std::unique_ptr` 或 `std::shared_ptr` 替代原始指针。
- **避免悬垂指针**：确保指针指向的对象未被提前释放。
- **深拷贝与浅拷贝**：如果需要复制 `vector`，需明确是深拷贝（复制指针指向的对象）还是浅拷贝（仅复制指针本身）。
